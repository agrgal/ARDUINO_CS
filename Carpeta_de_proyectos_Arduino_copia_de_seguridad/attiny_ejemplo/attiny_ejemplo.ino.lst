
/tmp/arduino_build_530597/attiny_ejemplo.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	0e c0       	rjmp	.+28     	; 0x1e <__ctors_end>
   2:	1d c0       	rjmp	.+58     	; 0x3e <__bad_interrupt>
   4:	1c c0       	rjmp	.+56     	; 0x3e <__bad_interrupt>
   6:	1b c0       	rjmp	.+54     	; 0x3e <__bad_interrupt>
   8:	1a c0       	rjmp	.+52     	; 0x3e <__bad_interrupt>
   a:	1a c0       	rjmp	.+52     	; 0x40 <__vector_5>
   c:	18 c0       	rjmp	.+48     	; 0x3e <__bad_interrupt>
   e:	17 c0       	rjmp	.+46     	; 0x3e <__bad_interrupt>
  10:	16 c0       	rjmp	.+44     	; 0x3e <__bad_interrupt>
  12:	15 c0       	rjmp	.+42     	; 0x3e <__bad_interrupt>
  14:	14 c0       	rjmp	.+40     	; 0x3e <__bad_interrupt>
  16:	13 c0       	rjmp	.+38     	; 0x3e <__bad_interrupt>
  18:	12 c0       	rjmp	.+36     	; 0x3e <__bad_interrupt>
  1a:	11 c0       	rjmp	.+34     	; 0x3e <__bad_interrupt>
  1c:	10 c0       	rjmp	.+32     	; 0x3e <__bad_interrupt>

0000001e <__ctors_end>:
__trampolines_start():
  1e:	11 24       	eor	r1, r1
  20:	1f be       	out	0x3f, r1	; 63
  22:	cf e5       	ldi	r28, 0x5F	; 95
  24:	d2 e0       	ldi	r29, 0x02	; 2
  26:	de bf       	out	0x3e, r29	; 62
  28:	cd bf       	out	0x3d, r28	; 61

0000002a <__do_clear_bss>:
__do_clear_bss():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  2a:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  2c:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  2e:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  30:	01 c0       	rjmp	.+2      	; 0x34 <.do_clear_bss_start>

00000032 <.do_clear_bss_loop>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  32:	1d 92       	st	X+, r1

00000034 <.do_clear_bss_start>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  34:	a0 37       	cpi	r26, 0x70	; 112
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  36:	b2 07       	cpc	r27, r18
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  38:	e1 f7       	brne	.-8      	; 0x32 <.do_clear_bss_loop>
.do_clear_bss_start():
  3a:	4c d0       	rcall	.+152    	; 0xd4 <main>
  3c:	9f c0       	rjmp	.+318    	; 0x17c <_exit>

0000003e <__bad_interrupt>:
__vector_1():
  3e:	e0 cf       	rjmp	.-64     	; 0x0 <__vectors>

00000040 <__vector_5>:
__vector_5():
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:308
      #error "cannot find Millis() timer overflow vector"
    #endif
  #else
    #error "Millis() timer not defined!"
  #endif
  {
  40:	1f 92       	push	r1
  42:	0f 92       	push	r0
  44:	0f b6       	in	r0, 0x3f	; 63
  46:	0f 92       	push	r0
  48:	11 24       	eor	r1, r1
  4a:	2f 93       	push	r18
  4c:	3f 93       	push	r19
  4e:	8f 93       	push	r24
  50:	9f 93       	push	r25
  52:	af 93       	push	r26
  54:	bf 93       	push	r27
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:311
    // copy these to local variables so they can be stored in registers
    // (volatile variables must be read from memory on every access)
    unsigned long m = millis_timer_millis;
  56:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <millis_timer_millis>
  5a:	90 91 66 00 	lds	r25, 0x0066	; 0x800066 <millis_timer_millis+0x1>
  5e:	a0 91 67 00 	lds	r26, 0x0067	; 0x800067 <millis_timer_millis+0x2>
  62:	b0 91 68 00 	lds	r27, 0x0068	; 0x800068 <millis_timer_millis+0x3>
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:312
    unsigned char f = millis_timer_fract;
  66:	30 91 64 00 	lds	r19, 0x0064	; 0x800064 <millis_timer_fract>
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:319
    static unsigned char correct_exact = 0;     // rollover intended
    if (++correct_exact < CORRECT_EXACT_MANY) {
      ++f;
    }
#endif
    f += FRACT_INC;
  6a:	26 e0       	ldi	r18, 0x06	; 6
  6c:	23 0f       	add	r18, r19
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:321

    if (f >= FRACT_MAX)
  6e:	2d 37       	cpi	r18, 0x7D	; 125
  70:	68 f1       	brcs	.+90     	; 0xcc <__vector_5+0x8c>
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:323
    {
      f -= FRACT_MAX;
  72:	29 e8       	ldi	r18, 0x89	; 137
  74:	23 0f       	add	r18, r19
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:324
      m += MILLIS_INC + 1;
  76:	03 96       	adiw	r24, 0x03	; 3
  78:	a1 1d       	adc	r26, r1
  7a:	b1 1d       	adc	r27, r1
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:331
    else
    {
      m += MILLIS_INC;
    }

    millis_timer_fract = f;
  7c:	20 93 64 00 	sts	0x0064, r18	; 0x800064 <millis_timer_fract>
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:332
    millis_timer_millis = m;
  80:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <millis_timer_millis>
  84:	90 93 66 00 	sts	0x0066, r25	; 0x800066 <millis_timer_millis+0x1>
  88:	a0 93 67 00 	sts	0x0067, r26	; 0x800067 <millis_timer_millis+0x2>
  8c:	b0 93 68 00 	sts	0x0068, r27	; 0x800068 <millis_timer_millis+0x3>
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:334
#ifndef CORRECT_EXACT_MICROS
    millis_timer_overflow_count++;
  90:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
  94:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
  98:	a0 91 62 00 	lds	r26, 0x0062	; 0x800062 <__DATA_REGION_ORIGIN__+0x2>
  9c:	b0 91 63 00 	lds	r27, 0x0063	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
  a0:	01 96       	adiw	r24, 0x01	; 1
  a2:	a1 1d       	adc	r26, r1
  a4:	b1 1d       	adc	r27, r1
  a6:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
  aa:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
  ae:	a0 93 62 00 	sts	0x0062, r26	; 0x800062 <__DATA_REGION_ORIGIN__+0x2>
  b2:	b0 93 63 00 	sts	0x0063, r27	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:336
#endif
  }
  b6:	bf 91       	pop	r27
  b8:	af 91       	pop	r26
  ba:	9f 91       	pop	r25
  bc:	8f 91       	pop	r24
  be:	3f 91       	pop	r19
  c0:	2f 91       	pop	r18
  c2:	0f 90       	pop	r0
  c4:	0f be       	out	0x3f, r0	; 63
  c6:	0f 90       	pop	r0
  c8:	1f 90       	pop	r1
  ca:	18 95       	reti
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:328
      f -= FRACT_MAX;
      m += MILLIS_INC + 1;
    }
    else
    {
      m += MILLIS_INC;
  cc:	02 96       	adiw	r24, 0x02	; 2
  ce:	a1 1d       	adc	r26, r1
  d0:	b1 1d       	adc	r27, r1
  d2:	d4 cf       	rjmp	.-88     	; 0x7c <__vector_5+0x3c>

000000d4 <main>:
main():
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1138
*/

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
    #if defined(WGM01) // if Timer0 has PWM
      TCCR0A = (1<<WGM01) | (1<<WGM00);
  d4:	83 e0       	ldi	r24, 0x03	; 3
  d6:	8a bd       	out	0x2a, r24	; 42
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1141
    #endif
    #if defined(TCCR0B) //The x61 has a wacky Timer0!
      TCCR0B = (MillisTimer_Prescale_Index << CS00);
  d8:	82 e0       	ldi	r24, 0x02	; 2
  da:	83 bf       	out	0x33, r24	; 51
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1162
    TCCR1A = 1<<WGM10;
    TCCR1B = (1<<WGM12) | (MillisTimer_Prescale_Index << CS10);
  #endif

  // this needs to be called before setup() or some functions won't work there
  sei();
  dc:	78 94       	sei
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1167

  #ifndef DISABLEMILLIS
    // Enable the overflow interrupt (this is the basic system tic-toc for millis)
    #if defined(TIMSK) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
      sbi(TIMSK, TOIE0);
  de:	89 b7       	in	r24, 0x39	; 57
  e0:	82 60       	ori	r24, 0x02	; 2
  e2:	89 bf       	out	0x39, r24	; 57
initToneTimerInternal():
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:958
    #elif defined(__AVR_ATtiny43__)
      TCCR1A = 3; //WGM 10=1, WGM11=1
      TCCR1B = 3; //prescaler of 64
    #elif (TIMER_TO_USE_FOR_TONE == 1) && defined(TCCR1) // ATtiny x5
      // Use the Tone Timer for fast PWM as phase correct not supported by this timer
      GTCCR = (1<<PWM1B);
  e4:	80 e4       	ldi	r24, 0x40	; 64
  e6:	8c bd       	out	0x2c, r24	; 44
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:959
      OCR1C = 0xFF; //Use 255 as the top to match with the others as this module doesn't have a 8bit PWM mode.
  e8:	8f ef       	ldi	r24, 0xFF	; 255
  ea:	8d bd       	out	0x2d, r24	; 45
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:960
      TCCR1 = (1<<CTC1) | (1<<PWM1A) | (ToneTimer_Prescale_Index << CS10);
  ec:	84 ec       	ldi	r24, 0xC4	; 196
  ee:	80 bf       	out	0x30, r24	; 48
main():
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1214
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
    #if defined(ADCSRA)
      // set a2d prescale factor
      // ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
      // dude, this is being called on startup. We know that ADCSRA is 0! Why add a RMW cycle?!
      ADCSRA = (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
  f0:	83 e8       	ldi	r24, 0x83	; 131
  f2:	86 b9       	out	0x06, r24	; 6
setup():
/home/aurelio/Arduino/attiny_ejemplo/attiny_ejemplo.ino:10
unsigned estado_salida = 0;
unsigned long tiempo_anterior = 0;

void setup() {
  // put your setup code here, to run once:
  DDRB = DDRB | (1<<PB2);
  f4:	ba 9a       	sbi	0x17, 2	; 23
loop():
/home/aurelio/Arduino/attiny_ejemplo/attiny_ejemplo.ino:20
  unsigned long tiempo = millis();

  if (tiempo - tiempo_anterior>PERIODO) {

      if (estado_salida == 0 ) {
        estado_salida = 1;
  f6:	21 e0       	ldi	r18, 0x01	; 1
  f8:	30 e0       	ldi	r19, 0x00	; 0
millis():
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:341
  }

  unsigned long millis()
  {
    unsigned long m;
    uint8_t oldSREG = SREG;
  fa:	8f b7       	in	r24, 0x3f	; 63
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:345

    // disable interrupts while we read millis_timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
    cli();
  fc:	f8 94       	cli
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:346
    m = millis_timer_millis;
  fe:	40 91 65 00 	lds	r20, 0x0065	; 0x800065 <millis_timer_millis>
 102:	50 91 66 00 	lds	r21, 0x0066	; 0x800066 <millis_timer_millis+0x1>
 106:	60 91 67 00 	lds	r22, 0x0067	; 0x800067 <millis_timer_millis+0x2>
 10a:	70 91 68 00 	lds	r23, 0x0068	; 0x800068 <millis_timer_millis+0x3>
/home/aurelio/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:347
    SREG = oldSREG;
 10e:	8f bf       	out	0x3f, r24	; 63
loop():
/home/aurelio/Arduino/attiny_ejemplo/attiny_ejemplo.ino:17

void loop() {
  // put your main code here, to run repeatedly:
  unsigned long tiempo = millis();

  if (tiempo - tiempo_anterior>PERIODO) {
 110:	80 91 6c 00 	lds	r24, 0x006C	; 0x80006c <tiempo_anterior>
 114:	90 91 6d 00 	lds	r25, 0x006D	; 0x80006d <tiempo_anterior+0x1>
 118:	a0 91 6e 00 	lds	r26, 0x006E	; 0x80006e <tiempo_anterior+0x2>
 11c:	b0 91 6f 00 	lds	r27, 0x006F	; 0x80006f <tiempo_anterior+0x3>
 120:	7a 01       	movw	r14, r20
 122:	8b 01       	movw	r16, r22
 124:	e8 1a       	sub	r14, r24
 126:	f9 0a       	sbc	r15, r25
 128:	0a 0b       	sbc	r16, r26
 12a:	1b 0b       	sbc	r17, r27
 12c:	d8 01       	movw	r26, r16
 12e:	c7 01       	movw	r24, r14
 130:	89 3e       	cpi	r24, 0xE9	; 233
 132:	93 40       	sbci	r25, 0x03	; 3
 134:	a1 05       	cpc	r26, r1
 136:	b1 05       	cpc	r27, r1
 138:	b8 f0       	brcs	.+46     	; 0x168 <main+0x94>
 13a:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <salida>
/home/aurelio/Arduino/attiny_ejemplo/attiny_ejemplo.ino:19

      if (estado_salida == 0 ) {
 13e:	e0 91 6a 00 	lds	r30, 0x006A	; 0x80006a <estado_salida>
 142:	f0 91 6b 00 	lds	r31, 0x006B	; 0x80006b <estado_salida+0x1>
 146:	ef 2b       	or	r30, r31
 148:	99 f4       	brne	.+38     	; 0x170 <main+0x9c>
/home/aurelio/Arduino/attiny_ejemplo/attiny_ejemplo.ino:20
        estado_salida = 1;
 14a:	30 93 6b 00 	sts	0x006B, r19	; 0x80006b <estado_salida+0x1>
 14e:	20 93 6a 00 	sts	0x006A, r18	; 0x80006a <estado_salida>
/home/aurelio/Arduino/attiny_ejemplo/attiny_ejemplo.ino:21
        salida = salida | (1<<PB2);
 152:	84 60       	ori	r24, 0x04	; 4
/home/aurelio/Arduino/attiny_ejemplo/attiny_ejemplo.ino:24
      } else {
        estado_salida = 0;
        salida = salida & ~(1<<PB2);
 154:	80 93 69 00 	sts	0x0069, r24	; 0x800069 <salida>
/home/aurelio/Arduino/attiny_ejemplo/attiny_ejemplo.ino:26
      }
        tiempo_anterior = tiempo;
 158:	40 93 6c 00 	sts	0x006C, r20	; 0x80006c <tiempo_anterior>
 15c:	50 93 6d 00 	sts	0x006D, r21	; 0x80006d <tiempo_anterior+0x1>
 160:	60 93 6e 00 	sts	0x006E, r22	; 0x80006e <tiempo_anterior+0x2>
 164:	70 93 6f 00 	sts	0x006F, r23	; 0x80006f <tiempo_anterior+0x3>
/home/aurelio/Arduino/attiny_ejemplo/attiny_ejemplo.ino:31
  }



  PORTB = salida;
 168:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <salida>
 16c:	88 bb       	out	0x18, r24	; 24
 16e:	c5 cf       	rjmp	.-118    	; 0xfa <main+0x26>
/home/aurelio/Arduino/attiny_ejemplo/attiny_ejemplo.ino:23

      if (estado_salida == 0 ) {
        estado_salida = 1;
        salida = salida | (1<<PB2);
      } else {
        estado_salida = 0;
 170:	10 92 6b 00 	sts	0x006B, r1	; 0x80006b <estado_salida+0x1>
 174:	10 92 6a 00 	sts	0x006A, r1	; 0x80006a <estado_salida>
/home/aurelio/Arduino/attiny_ejemplo/attiny_ejemplo.ino:24
        salida = salida & ~(1<<PB2);
 178:	8b 7f       	andi	r24, 0xFB	; 251
 17a:	ec cf       	rjmp	.-40     	; 0x154 <main+0x80>

0000017c <_exit>:
exit():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 17c:	f8 94       	cli

0000017e <__stop_program>:
__stop_program():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 17e:	ff cf       	rjmp	.-2      	; 0x17e <__stop_program>
